# Exploitability Measurement Design

This document defines how exploitability is calculated and used for convergence detection in oracle Solver.

## Definition

### Exploitability in Heads-Up Postflop

**Exploitability** is the sum of both players' best-response gains. If player 1 can gain X by deviating from the current strategy, and player 2 can gain Y by deviating, then:

```
exploitability = X + Y
```

This is the standard definition for two-player zero-sum games. It represents the total "distance" from Nash equilibrium—the maximum combined gain both players could achieve by deviating optimally.

### Why Sum Both Players?

In a zero-sum game, if one player deviates optimally, the other player's EV decreases. However, exploitability measures the **total deviation potential**, not just one player's gain. This ensures:

- Symmetric measure: Exploitability is the same regardless of which player we consider
- Convergence target: As exploitability → 0, both players approach optimal play
- Standard definition: Matches academic and industry standard (e.g., PioSOLVER, GTO+)

## Algorithm

### Best-Response Calculation

For each player, compute their best-response value:

1. **Forward traversal**: Traverse the game tree from root to terminal nodes
2. **At each decision node for the target player**: Choose the action that maximizes EV given the opponent's current strategy
3. **At each decision node for the opponent**: Use their current strategy (mixed strategy from CFR)
4. **At terminal nodes**: Compute EV using hand evaluator
5. **Backward pass**: Propagate EV up the tree

### Exploitability Formula

```
exploitability = BR_value_player1(current_strategy) + BR_value_player2(current_strategy)
```

Where `BR_value_player1` is the EV player 1 achieves by playing best-response against player 2's current strategy, and vice versa.

### Implementation Notes

- **Full tree traversal**: Best-response requires traversing the entire tree (no pruning)
- **Strategy lookup**: At opponent nodes, sample from their current strategy distribution
- **Terminal EV**: Use hand evaluator to compute showdown EV or fold payouts
- **Reach probabilities**: Track reach probabilities for both players during traversal

## Where It Runs

### In-Process Rust Engine

Exploitability calculation runs entirely within the Rust engine, called by the Solve Manager during the iteration loop.

### Convergence Checking

The Solve Manager calls exploitability calculation:
- **Periodically**: Every N iterations (e.g., every 1000 iterations)
- **On demand**: When user requests exploitability check
- **At convergence**: When checking if solve has converged

### Performance Considerations

Best-response calculation is O(N) where N is the number of nodes. For a 100k-node tree:
- Single best-response pass: ~1-5ms
- Full exploitability (both players): ~2-10ms
- Acceptable overhead for convergence checking

## Precision and Stopping

### User-Defined Threshold

Users can specify an exploitability threshold (e.g., 0.1% of pot). The solver stops when:

```
exploitability < threshold
```

### Threshold Units

Exploitability is expressed in **big blinds** (bb). For a 100bb pot:
- 0.1% pot = 0.1 bb
- 0.01% pot = 0.01 bb

### Stopping Conditions

The solver stops when **any** of these conditions are met:

1. **Exploitability threshold**: `exploitability < user_threshold`
2. **Iteration cap**: `iterations >= max_iterations`
3. **Time cap**: `elapsed_time >= max_time`

These conditions are checked in order of priority (exploitability first, then iteration cap, then time cap).

### Convergence Tracking

The Solve Manager tracks:
- Current exploitability value
- Iteration count
- Elapsed time
- Convergence history (for visualization/debugging)

## Output

### Engine API

The engine exposes exploitability as:

```rust
pub struct ConvergenceMetrics {
    pub exploitability: f64,  // Total exploitability (sum of both players)
    pub player1_br_value: f64,  // Player 1's best-response value
    pub player2_br_value: f64,  // Player 2's best-response value
    pub iterations: u64,
    pub elapsed_time: Duration,
}
```

### Single Scalar vs Per-Player

The primary output is the **single scalar exploitability** (sum of both players). Per-player values are also exposed for:
- Debugging
- Visualization
- User understanding

But convergence decisions are made based on the total exploitability.

## Implementation Phases

### Phase 0 (Current)

- Design document (this file)
- Interface definition in code

### Phase 2 (CFR+ Engine)

- Best-response calculation implementation
- Exploitability computation
- Convergence checking integration

### Phase 3+ (Future)

- Incremental exploitability updates (avoid full recalculation)
- Approximate exploitability for very large trees
- Exploitability visualization in UI
