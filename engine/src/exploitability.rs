//! Exploitability calculation via best-response traversal.
//!
//! Uses Rayon to compute both players' best-response values in parallel.
//! Both traversals are read-only (& refs only) so no locking is needed.

use std::time::Duration;
use rayon;
use crate::cfr::RegretStorage;
use crate::node::{GameTree, Node, NodeId, Player};
use crate::test_tree::terminal_ev_table;
use std::collections::HashMap;

/// Convergence metrics returned after an exploitability check.
pub struct ConvergenceMetrics {
    /// Total exploitability = ip_br_value + oop_br_value (in bb)
    pub exploitability: f64,
    /// IP's best-response gain against OOP's average strategy
    pub ip_br_value: f64,
    /// OOP's best-response gain against IP's average strategy
    pub oop_br_value: f64,
    pub iterations: u64,
    pub elapsed_time: Duration,
}

/// Compute exploitability using the default 9-node test terminal EV table.
///
/// Both players' best-response traversals run in parallel via `rayon::join`.
pub fn compute_exploitability(
    tree: &GameTree,
    storage: &RegretStorage,
    iteration: u64,
    elapsed: Duration,
) -> ConvergenceMetrics {
    let evs = terminal_ev_table();
    let (ip_br_value, oop_br_value) = rayon::join(
        || br_traverse_with_evs(tree, storage, &evs, 0, Player::IP, 1.0),
        || br_traverse_with_evs(tree, storage, &evs, 0, Player::OOP, 1.0),
    );

    ConvergenceMetrics {
        exploitability: ip_br_value + oop_br_value,
        ip_br_value,
        oop_br_value,
        iterations: iteration,
        elapsed_time: elapsed,
    }
}

/// Compute exploitability with a custom terminal EV table.
///
/// Use this when solving trees other than the default 9-node test tree.
/// Both players' best-response traversals run in parallel via `rayon::join`.
pub fn compute_exploitability_with_evs(
    tree: &GameTree,
    storage: &RegretStorage,
    terminal_evs: &HashMap<NodeId, f64>,
    iteration: u64,
    elapsed: Duration,
) -> ConvergenceMetrics {
    let (ip_br_value, oop_br_value) = rayon::join(
        || br_traverse_with_evs(tree, storage, terminal_evs, 0, Player::IP, 1.0),
        || br_traverse_with_evs(tree, storage, terminal_evs, 0, Player::OOP, 1.0),
    );

    ConvergenceMetrics {
        exploitability: ip_br_value + oop_br_value,
        ip_br_value,
        oop_br_value,
        iterations: iteration,
        elapsed_time: elapsed,
    }
}

/// Recursive best-response traversal with an explicit EV table.
///
/// Returns EV from `traversing_player`'s perspective.
/// `reach_opponent` is the probability the opponent reaches this node.
fn br_traverse_with_evs(
    tree: &GameTree,
    storage: &RegretStorage,
    terminal_evs: &HashMap<NodeId, f64>,
    node_id: NodeId,
    traversing_player: Player,
    reach_opponent: f64,
) -> f64 {
    match tree.get(node_id).expect("invalid node id") {
        Node::Terminal { .. } => {
            let ip_ev = terminal_evs[&node_id];
            if traversing_player == Player::IP { ip_ev } else { -ip_ev }
        }

        Node::Decision { player, children, infoset_id, .. } => {
            let children = children.clone();
            let infoset_id = *infoset_id as usize;
            let acting_player = *player;

            if acting_player == traversing_player {
                // Best response: choose the action with the highest EV
                children.iter().map(|&child_id| {
                    br_traverse_with_evs(
                        tree, storage, terminal_evs, child_id, traversing_player, reach_opponent,
                    )
                }).fold(f64::NEG_INFINITY, f64::max)
            } else {
                // Opponent plays their average strategy
                let strategy = storage.average_strategy(infoset_id);
                children.iter().zip(strategy.iter()).map(|(&child_id, &prob)| {
                    let child_ev = br_traverse_with_evs(
                        tree, storage, terminal_evs, child_id, traversing_player,
                        reach_opponent * prob,
                    );
                    prob * child_ev
                }).sum()
            }
        }

        Node::Chance { children, .. } => {
            let children = children.clone();
            let n = children.len() as f64;
            children.iter().map(|&child_id| {
                br_traverse_with_evs(
                    tree, storage, terminal_evs, child_id, traversing_player, reach_opponent,
                ) / n
            }).sum()
        }
    }
}

/// Kept for internal use â€” wraps `br_traverse_with_evs` using the default EV table.
#[allow(dead_code)]
fn br_traverse(
    tree: &GameTree,
    storage: &RegretStorage,
    node_id: NodeId,
    traversing_player: Player,
    reach_opponent: f64,
) -> f64 {
    let evs = terminal_ev_table();
    br_traverse_with_evs(tree, storage, &evs, node_id, traversing_player, reach_opponent)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cfr::CfrSolver;
    use crate::test_tree::{build_test_tree, build_test_tree_chance, terminal_ev_table_chance};

    #[test]
    fn test_exploitability_nonnegative() {
        let tree = build_test_tree();
        let solver = CfrSolver::new(tree.clone());
        let metrics = compute_exploitability(&tree, &solver.storage, 0, Duration::ZERO);
        assert!(metrics.exploitability >= 0.0, "exploitability must be >= 0");
    }

    #[test]
    fn test_exploitability_decreases_over_iterations() {
        let tree = build_test_tree();
        let mut solver = CfrSolver::new(tree.clone());

        for _ in 0..100 {
            solver.run_iteration();
        }
        let early = compute_exploitability(&tree, &solver.storage, 100, Duration::ZERO);

        for _ in 0..4_900 {
            solver.run_iteration();
        }
        let late = compute_exploitability(&tree, &solver.storage, 5_000, Duration::ZERO);

        assert!(
            late.exploitability < early.exploitability,
            "exploitability should decrease: early={:.6}  late={:.6}",
            early.exploitability,
            late.exploitability,
        );
    }

    #[test]
    fn test_exploitability_convergence() {
        let tree = build_test_tree();
        let mut solver = CfrSolver::new(tree.clone());
        for _ in 0..10_000 {
            solver.run_iteration();
        }
        let metrics = compute_exploitability(&tree, &solver.storage, 10_000, Duration::ZERO);
        assert!(
            metrics.exploitability < 0.01,
            "exploitability after 10k iters should be < 0.01, got {}",
            metrics.exploitability,
        );
    }

    #[test]
    fn test_exploitability_chance_tree_nonnegative() {
        let tree = build_test_tree_chance();
        let evs = terminal_ev_table_chance();
        let solver = CfrSolver::new_with_evs(tree.clone(), evs.clone());
        let metrics = compute_exploitability_with_evs(&tree, &solver.storage, &evs, 0, Duration::ZERO);
        assert!(metrics.exploitability >= 0.0, "chance tree exploitability must be >= 0");
    }

    #[test]
    fn test_exploitability_chance_tree_decreases() {
        let tree = build_test_tree_chance();
        let evs = terminal_ev_table_chance();

        let mut solver = CfrSolver::new_with_evs(tree.clone(), evs.clone());
        for _ in 0..100 {
            solver.run_iteration();
        }
        let early = compute_exploitability_with_evs(&tree, &solver.storage, &evs, 100, Duration::ZERO);

        for _ in 0..4_900 {
            solver.run_iteration();
        }
        let late = compute_exploitability_with_evs(&tree, &solver.storage, &evs, 5_000, Duration::ZERO);

        assert!(
            late.exploitability < early.exploitability,
            "chance tree exploitability should decrease: early={:.6}  late={:.6}",
            early.exploitability,
            late.exploitability,
        );
    }
}
