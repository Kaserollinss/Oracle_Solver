//! Exploitability calculation via best-response traversal.
//!
//! Uses Rayon to compute both players' best-response values in parallel.
//! Both traversals are read-only (& refs only) so no locking is needed.

use std::time::Duration;
use rayon;
use crate::cfr::RegretStorage;
use crate::node::{GameTree, Node, NodeId, Player};
use crate::test_tree::terminal_ev_table;

/// Convergence metrics returned after an exploitability check.
pub struct ConvergenceMetrics {
    /// Total exploitability = ip_br_value + oop_br_value (in bb)
    pub exploitability: f64,
    /// IP's best-response gain against OOP's average strategy
    pub ip_br_value: f64,
    /// OOP's best-response gain against IP's average strategy
    pub oop_br_value: f64,
    pub iterations: u64,
    pub elapsed_time: Duration,
}

/// Compute exploitability. Both players' best-response traversals run in
/// parallel via `rayon::join` â€” safe because all arguments are shared refs.
pub fn compute_exploitability(
    tree: &GameTree,
    storage: &RegretStorage,
    iteration: u64,
    elapsed: Duration,
) -> ConvergenceMetrics {
    let (ip_br_value, oop_br_value) = rayon::join(
        || best_response_value(tree, storage, Player::IP),
        || best_response_value(tree, storage, Player::OOP),
    );

    ConvergenceMetrics {
        exploitability: ip_br_value + oop_br_value,
        ip_br_value,
        oop_br_value,
        iterations: iteration,
        elapsed_time: elapsed,
    }
}

/// Compute the best-response value for `traversing_player` against the opponent's
/// average strategy. Returns the gain above zero (EV from the traversing player's perspective).
fn best_response_value(tree: &GameTree, storage: &RegretStorage, player: Player) -> f64 {
    br_traverse(tree, storage, 0, player, 1.0)
}

/// Recursive best-response traversal.
///
/// Returns EV from `traversing_player`'s perspective.
/// `reach_opponent` is the probability the opponent reaches this node.
fn br_traverse(
    tree: &GameTree,
    storage: &RegretStorage,
    node_id: NodeId,
    traversing_player: Player,
    reach_opponent: f64,
) -> f64 {
    let evs = terminal_ev_table();
    match tree.get(node_id).expect("invalid node id") {
        Node::Terminal { .. } => {
            let ip_ev = evs[&node_id];
            // Return EV from traversing player's perspective
            if traversing_player == Player::IP { ip_ev } else { -ip_ev }
        }

        Node::Decision { player, children, infoset_id, .. } => {
            let children = children.clone();
            let infoset_id = *infoset_id as usize;
            let acting_player = *player;

            if acting_player == traversing_player {
                // Best response: choose the action with the highest EV
                children.iter().map(|&child_id| {
                    br_traverse(tree, storage, child_id, traversing_player, reach_opponent)
                }).fold(f64::NEG_INFINITY, f64::max)
            } else {
                // Opponent plays their average strategy
                let strategy = storage.average_strategy(infoset_id);
                children.iter().zip(strategy.iter()).map(|(&child_id, &prob)| {
                    let child_ev = br_traverse(
                        tree, storage, child_id, traversing_player, reach_opponent * prob,
                    );
                    prob * child_ev
                }).sum()
            }
        }

        Node::Chance { .. } => panic!("test tree has no chance nodes"),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cfr::CfrSolver;
    use crate::test_tree::build_test_tree;

    #[test]
    fn test_exploitability_nonnegative() {
        let tree = build_test_tree();
        let solver = CfrSolver::new(tree.clone());
        let metrics = compute_exploitability(&tree, &solver.storage, 0, Duration::ZERO);
        assert!(metrics.exploitability >= 0.0, "exploitability must be >= 0");
    }

    #[test]
    fn test_exploitability_decreases_over_iterations() {
        let tree = build_test_tree();
        let mut solver = CfrSolver::new(tree.clone());

        for _ in 0..100 {
            solver.run_iteration();
        }
        let early = compute_exploitability(&tree, &solver.storage, 100, Duration::ZERO);

        for _ in 0..4_900 {
            solver.run_iteration();
        }
        let late = compute_exploitability(&tree, &solver.storage, 5_000, Duration::ZERO);

        assert!(
            late.exploitability < early.exploitability,
            "exploitability should decrease: early={:.6}  late={:.6}",
            early.exploitability,
            late.exploitability,
        );
    }

    #[test]
    fn test_exploitability_convergence() {
        let tree = build_test_tree();
        let mut solver = CfrSolver::new(tree.clone());
        for _ in 0..10_000 {
            solver.run_iteration();
        }
        let metrics = compute_exploitability(&tree, &solver.storage, 10_000, Duration::ZERO);
        assert!(
            metrics.exploitability < 0.01,
            "exploitability after 10k iters should be < 0.01, got {}",
            metrics.exploitability,
        );
    }
}
